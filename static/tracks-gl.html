<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8' />
    <title>Custom GL Layer</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id='map'></div>
    <script type="module">
        // Import and initialize FogMap first
        import init, { FogMap } from '../pkg/fogcore.js';

        async function loadZip(filename) {
            const response = await fetch(`${filename}`);
            const arrayBuffer = await response.arrayBuffer();
            return new Uint8Array(arrayBuffer);
        }

        let fogMap; // Declare fogMap in outer scope

        async function initializeMap() {
            await init();
            fogMap = await FogMap.new_no_renderer();

            const filename = 'tiles.zip';
            try {
                const data = await loadZip(filename);
                fogMap.add_fow_zip(data);
                console.log(`Loaded ${filename}`);
            } catch (error) {
                console.error(`Failed to load ${filename}:`, error);
                throw error;
            }

            mapboxgl.accessToken = 'pk.eyJ1IjoidGF2aW1vcmkiLCJhIjoiY20wdGVxbjU2MDJmcjJpc2c2bmFhNGxsYiJ9.IwN3EwUWqepX8l7sJANEpw';

            const map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/light-v11',
                center: [0, 0],
                zoom: 2,
                antialias: true,
                projection: 'mercator'
            });

            // Custom layer implementation
            const customLayer = {
                id: 'custom-layer',
                type: 'custom',
                renderingMode: '2d',

                onAdd: function (map, gl) {
                    // create GLSL source for vertex shader
                    const vertexSource = `
                    precision mediump float;
                    uniform mat4 u_matrix;
                    attribute vec2 a_pos;
                    void main() {
                        gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);
                        gl_PointSize = 5.0;
                    }`;

                    // create GLSL source for fragment shader (for points)
                    const fragmentSource = `
                    precision mediump float;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) {
                            discard; // Don't draw anything outside the circle
                        } else {
                            gl_FragColor = vec4(1.0); // White circle
                        }
                    }`;

                    // create a vertex shader
                    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vertexShader, vertexSource);
                    gl.compileShader(vertexShader);

                    // Check vertex shader compilation
                    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                        console.error('Vertex shader compilation failed:', gl.getShaderInfoLog(vertexShader));
                        return;
                    }

                    // create a fragment shader
                    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fragmentShader, fragmentSource);
                    gl.compileShader(fragmentShader);

                    // Check fragment shader compilation
                    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                        console.error('Fragment shader compilation failed:', gl.getShaderInfoLog(fragmentShader));
                        return;
                    }

                    // link the two shaders into a WebGL program
                    this.program = gl.createProgram();
                    gl.attachShader(this.program, vertexShader);
                    gl.attachShader(this.program, fragmentShader);
                    gl.linkProgram(this.program);

                    this.aPos = gl.getAttribLocation(this.program, 'a_pos');

                    // Just create the buffer once
                    this.buffer = gl.createBuffer();

                    // Create framebuffer and texture for the mask
                    this.maskTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.maskTexture);
                    gl.texImage2D(
                        gl.TEXTURE_2D, 0, gl.RGBA,
                        gl.canvas.width, gl.canvas.height,
                        0, gl.RGBA, gl.UNSIGNED_BYTE, null
                    );
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

                    this.maskFramebuffer = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this.maskFramebuffer);
                    gl.framebufferTexture2D(
                        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                        gl.TEXTURE_2D, this.maskTexture, 0
                    );

                    // Create a full-screen quad for rendering the final mask
                    this.quadBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                    gl.bufferData(
                        gl.ARRAY_BUFFER,
                        new Float32Array([
                            -1, -1,
                            1, -1,
                            -1, 1,
                            1, 1
                        ]),
                        gl.STATIC_DRAW
                    );

                    // Additional shader for rendering the final composite
                    const finalVertexSource = `
                    precision mediump float;
                    attribute vec2 a_position;
                    varying vec2 v_texCoord;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                        v_texCoord = a_position * 0.5 + 0.5;
                    }`;

                    const finalFragmentSource = `
                    precision mediump float;
                    uniform sampler2D u_texture;
                    varying vec2 v_texCoord;
                    void main() {
                        vec4 mask = texture2D(u_texture, v_texCoord);
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.5 * (1.0 - mask.r)); // Half-transparent black fog
                    }`;

                    // Create and compile the final shaders
                    this.finalProgram = createShaderProgram(gl, finalVertexSource, finalFragmentSource);
                    this.finalPositionAttribute = gl.getAttribLocation(this.finalProgram, 'a_position');
                },

                render: function (gl, matrix) {
                    // First pass: render points to the mask texture
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this.maskFramebuffer);
                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                    // Clear with black (fully transparent in the mask)
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    // Enable blending for the points
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

                    const bounds = map.getBounds();
                    const sw = mapboxgl.MercatorCoordinate.fromLngLat(bounds.getSouthWest(), 0);
                    const ne = mapboxgl.MercatorCoordinate.fromLngLat(bounds.getNorthEast(), 0);

                    const pixels = fogMap.get_bounding_mercator_pixels(
                        sw.x,
                        sw.y,
                        ne.x,
                        ne.y
                    );

                    // Get the latest pixels
                    const numPoints = pixels.length / 2;
                    if (numPoints === 0) {
                        console.log('No points to render');
                        return;
                    }

                    console.log(`Rendering ${numPoints} points`); // Debug log

                    // Update buffer with new pixel data
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.bufferData(
                        gl.ARRAY_BUFFER,
                        new Float32Array(pixels),
                        gl.DYNAMIC_DRAW
                    );

                    gl.useProgram(this.program);
                    gl.uniformMatrix4fv(
                        gl.getUniformLocation(this.program, 'u_matrix'),
                        false,
                        matrix
                    );
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.enableVertexAttribArray(this.aPos);
                    gl.vertexAttribPointer(this.aPos, 2, gl.FLOAT, false, 0, 0);

                    // Draw the points
                    gl.drawArrays(gl.POINTS, 0, numPoints);

                    // Second pass: render the mask to the screen
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                    gl.useProgram(this.finalProgram);

                    // Set the blend mode for the final pass
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                    gl.bindTexture(gl.TEXTURE_2D, this.maskTexture);

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                    gl.enableVertexAttribArray(this.finalPositionAttribute);
                    gl.vertexAttribPointer(this.finalPositionAttribute, 2, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                }
            };

            map.on('load', () => {
                map.addLayer(customLayer);
            });
        }

        // Start initialization
        initializeMap().catch(console.error);

        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('Vertex shader compilation failed:', gl.getShaderInfoLog(vertexShader));
                return null;
            }

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('Fragment shader compilation failed:', gl.getShaderInfoLog(fragmentShader));
                return null;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking failed:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

    </script>
</body>

</html>