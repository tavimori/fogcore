<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8' />
    <title>Custom GL Layer</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id='map'></div>
    <script type="module">
        // Import and initialize FogMap first
        import init, { FogMap } from '../pkg/fogcore.js';

        async function loadZip(filename) {
            const response = await fetch(`${filename}`);
            const arrayBuffer = await response.arrayBuffer();
            return new Uint8Array(arrayBuffer);
        }

        let fogMap; // Declare fogMap in outer scope

        async function initializeMap() {
            await init();
            fogMap = await FogMap.new_no_renderer();

            const filename = 'tiles.zip';
            try {
                const data = await loadZip(filename);
                fogMap.add_fow_zip(data);
                console.log(`Loaded ${filename}`);
            } catch (error) {
                console.error(`Failed to load ${filename}:`, error);
                throw error;
            }

            mapboxgl.accessToken = 'pk.eyJ1IjoidGF2aW1vcmkiLCJhIjoiY20wdGVxbjU2MDJmcjJpc2c2bmFhNGxsYiJ9.IwN3EwUWqepX8l7sJANEpw';

            const map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/light-v11',
                center: [0, 0],
                zoom: 2,
                antialias: true,
                projection: 'mercator'
            });

            // Custom layer implementation
            const customLayer = {
                id: 'custom-layer',
                type: 'custom',
                renderingMode: '2d',

                onAdd: function (map, gl) {
                    // create GLSL source for vertex shader
                    const vertexSource = `
                    precision mediump float;
                    uniform mat4 u_matrix;
                    attribute vec2 a_pos;
                    void main() {
                        gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);
                        gl_PointSize = 10.0;
                    }`;

                    // create GLSL source for fragment shader
                    const fragmentSource = `
                    precision mediump float;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) {
                            discard;
                        }
                        gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);
                    }`;

                    // create a vertex shader
                    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vertexShader, vertexSource);
                    gl.compileShader(vertexShader);

                    // Check vertex shader compilation
                    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                        console.error('Vertex shader compilation failed:', gl.getShaderInfoLog(vertexShader));
                        return;
                    }

                    // create a fragment shader
                    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fragmentShader, fragmentSource);
                    gl.compileShader(fragmentShader);

                    // Check fragment shader compilation
                    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                        console.error('Fragment shader compilation failed:', gl.getShaderInfoLog(fragmentShader));
                        return;
                    }

                    // link the two shaders into a WebGL program
                    this.program = gl.createProgram();
                    gl.attachShader(this.program, vertexShader);
                    gl.attachShader(this.program, fragmentShader);
                    gl.linkProgram(this.program);

                    this.aPos = gl.getAttribLocation(this.program, 'a_pos');

                    // Just create the buffer once
                    this.buffer = gl.createBuffer();
                },

                render: function (gl, matrix) {
                    const bounds = map.getBounds();
                    const sw = mapboxgl.MercatorCoordinate.fromLngLat(bounds.getSouthWest(), 0);
                    const ne = mapboxgl.MercatorCoordinate.fromLngLat(bounds.getNorthEast(), 0);

                    // TODO: use the correct zoom level
                    const pixels = fogMap.get_bounding_mercator_pixels(
                        sw.x,
                        sw.y,
                        ne.x,
                        ne.y
                    );

                    // Get the latest pixels
                    const numPoints = pixels.length / 2;

                    // Update buffer with new pixel data
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.bufferData(
                        gl.ARRAY_BUFFER,
                        new Float32Array(pixels),
                        gl.DYNAMIC_DRAW  // Changed to DYNAMIC_DRAW since we update frequently
                    );

                    gl.useProgram(this.program);
                    gl.uniformMatrix4fv(
                        gl.getUniformLocation(this.program, 'u_matrix'),
                        false,
                        matrix
                    );
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.enableVertexAttribArray(this.aPos);
                    gl.vertexAttribPointer(this.aPos, 2, gl.FLOAT, false, 0, 0);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    gl.drawArrays(gl.POINTS, 0, numPoints);
                }
            };

            map.on('load', () => {
                map.addLayer(customLayer);
            });
        }

        // Start initialization
        initializeMap().catch(console.error);


    </script>
</body>

</html>