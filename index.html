<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Fork my world</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

    <script src='https://api.mapbox.com/mapbox-gl-js/v2.3.1/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.3.1/mapbox-gl.css' rel='stylesheet' />

    <script src="filedrop-min.js"></script>
    <script src="pako.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .map-overlay {
            position: absolute;
            width: 25%;
            top: 0;
            left: 0;
            padding: 10px;
            background-color: transparent;
        }

        #zdir {
            border: 5px solid blue;
            width: 400px;
            height: 200px;
            background-color: grey;
        }
    </style>

</head>

<body>

    <div id='map'></div>
    <div class="map-overlay top">
        <div id="zdir">
            <h1>Fork my world</h1>
            <p>Drop a directory hereâ€¦</p>
            <p>Drag one or more files to this Drop Zone ...</p>
        </div>
    </div>



    <script>
        const FILENAME_MASK1 = "olhwjsktri";
        const FILENAME_MASK2 = "eizxdwknmo";
        var FILENAME_ENCODING = {};
        for (var i = 0; i < FILENAME_MASK1.length; i++) {
            FILENAME_ENCODING[FILENAME_MASK1.charAt(i)] = i
        }
        const MAP_WIDTH = 512
        const TILE_WIDTH = 128
        const TILE_HEADER_LEN = TILE_WIDTH ** 2;
        const TILE_HEADER_SIZE = TILE_HEADER_LEN * 2;
        const BLOCK_BITMAP_SIZE = 512;
        const BLOCK_EXTRA_DATA = 3
        const BLOCK_SIZE = BLOCK_BITMAP_SIZE + BLOCK_EXTRA_DATA
        const BITMAP_WIDTH = 64

        const ZOOM_LEVEL = 8

        class Block {
            constructor(x, y, data) {
                this.x = x;
                this.y = y;
                this.bitmap = data.slice(0, BLOCK_BITMAP_SIZE);
                this.extraData = data.slice(BLOCK_BITMAP_SIZE, BLOCK_SIZE);
            }

            is_visited(x, y) {
                var bit_offset = 7 - x % 8;
                var i = Math.round(x / 8);
                var j = y;
                return this.bitmap[i + j * 8] & (1 << bit_offset);
            }

        }

        function tile_x_y_to_lng_lat(x, y) {
            lng = x / 512 * 360 - 180;
            // y : 0-256-512 lat : 90-0--90
            lat = Math.atan(Math.sinh(Math.PI - 2 * Math.PI * y / 512)) * 180 / Math.PI;
            return [lng, lat];
        }

        class Tile {
            constructor(filename, data) {

                // TODO: try catch
                this.id = filename.slice(4, -2).split("").map(idMasked => FILENAME_ENCODING[idMasked]).join("");
                this.x = this.id % MAP_WIDTH;
                this.y = Math.round(this.id / MAP_WIDTH);
                // console.log()
                console.log(`Loading tile. id: ${this.id}, x: ${this.x}, y: ${this.y}`);

                // TODO: try catch
                this.data = pako.inflate(data);

                var header = new Uint16Array(this.data.slice(0, TILE_HEADER_SIZE).buffer)
                // headerBuf = new Buffer(this.data.slice(0, TILE_HEADER_SIZE))
                // header = new Uint16Array(headerBuf.buffer, buf.byteOffset, buf.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                // debugger;
                this.blocks = {}

                for (var i = 0; i < header.length; i++) {
                    var block_idx = header[i];
                    if (block_idx > 0) {
                        let block_x = i % TILE_WIDTH;
                        let block_y = Math.round(i / TILE_WIDTH)
                        let start_offset = TILE_HEADER_SIZE + (block_idx - 1) * BLOCK_SIZE
                        let end_offset = start_offset + BLOCK_SIZE
                        var block_data = this.data.slice(start_offset, end_offset);
                        this.blocks[[block_x, block_y]] = new Block(block_x, block_y, block_data)
                    }
                }
                // console.log(this.data);
            }

            bounds() {
                let sw = tile_x_y_to_lng_lat(this.x, this.y + 1);
                let se = tile_x_y_to_lng_lat(this.x + 1, this.y + 1);
                let ne = tile_x_y_to_lng_lat(this.x + 1, this.y);
                let nw = tile_x_y_to_lng_lat(this.x, this.y);
                return [sw, se, ne, nw];
            }

        }
        class FogMap {
            constructor(map) {
                this.tiles = {};
                this.map = map;
            }

            addTile(x, y, tile) {
                this.tiles[[x, y]] = tile;

                var tileCanvas = document.createElement("canvas");
                tileCanvas.id = tile.id.toString();

                var size = Math.round(TILE_WIDTH * BITMAP_WIDTH / ZOOM_LEVEL)
                size = size + 1; // FIXME
                tileCanvas.width = size;
                tileCanvas.height = size;

                var ctx = tileCanvas.getContext("2d");

                var blocks = Object.values(tile.blocks);
                for (var i = 0; i < blocks.length; i++) {
                    var block = blocks[i];
                    for (var j = 0; j < BITMAP_WIDTH; j++) {
                        for (var k = 0; k < BITMAP_WIDTH; k++) {
                            var x = block.x * BITMAP_WIDTH + j;
                            var y = block.y * BITMAP_WIDTH + k;
                            x = Math.round(x / ZOOM_LEVEL);
                            y = Math.round(y / ZOOM_LEVEL);
                            if (block.is_visited(j, k)) {
                                ctx.fillStyle = "#000000";
                                ctx.fillRect(x, size-y, 1, 1);
                                // im.putpixel((x, y), ImageColor.getcolor('black', 'RGB'))
                            }

                        }
                    }
                }

                // ctx.fillRect(30, 30, 100, 100);

                // document.body.appendChild(tileCanvas);
                // debugger;
                // load tile to map
                map.addSource(tile.id.toString(), {
                    type: 'canvas',
                    canvas: tileCanvas,
                    animate: true,
                    coordinates: tile.bounds()
                });

                map.addLayer({
                    id: tile.id.toString(),
                    type: 'raster',
                    source: tile.id.toString()
                });

                map.flyTo({
                    center: tile.bounds()[0],
                    essential: true // this animation is considered essential with respect to prefers-reduced-motion
                });
            }
        }





        mapboxgl.accessToken = 'pk.eyJ1IjoidGF2aW1vcmkiLCJhIjoiY2ozeHh3NXdjMDAwYTJ3bnk2ZXhqbTkzbiJ9.BGLmrBqqXkZv50HKrwaZRQ';
        var map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v11',
            center: [114.20592531593752, 22.690129049232496],
            zoom: 10
        });


        // Add zoom and rotation controls to the map.
        map.addControl(new mapboxgl.NavigationControl());

        map.on('load', function () {
            var fogMap = new FogMap(map);

            var zone = new FileDrop('zdir', { input: false });

            zone.event('upload', function (e) {
                while (cleared = zone.el.firstChild) {
                    zone.el.removeChild(zone.el.firstChild);
                }

                var error = function () { alert('Problem reading the file system.'); }

                var done = function (files) {
                    // files is standard FileDrop's FileList object.
                    files.each(function (file) {
                        // file is FileDrop.File with native objects accessible
                        // as file.nativeFile and file.nativeEntry.
                        var node = document.createElement('p');
                        node.innerText = file.name

                        if (file.nativeFile) {
                            // This is a file. We can use any FileDrop method here
                            // like sendTo() and readData() - see below.
                            node.innerText += ' (' + file.size + ')';

                            file.readData(
                                function (data) {
                                    var tile = new Tile(file.name, data)
                                    fogMap.addTile(tile.x, tile.y, tile);
                                },
                                function (e) { alert('Terrible error!') }
                            )
                            // var tile = new Tile(file.name, )

                        } else {
                            // This is a directory - it has no File API object.
                            node.innerHTML = '<b>' + node.innerHTML + '/</b>';
                        }

                        zone.el.appendChild(node);
                    });

                    // Let's show thumbs of images using FileDrop.File methods.
                    files.images().each(function (file) {
                        file.readDataURI(function (uri) {
                            var img = new Image;
                            img.src = uri;
                            zone.el.appendChild(img);
                        });
                    });
                };

                zone.eventFiles(e).each(function (root) {
                    if (root.listEntries(done, error)) {
                        // Success.
                    } else if (!root.nativeEntry) {
                        zone.el.innerHTML = '<p><b>File System API is not' +
                            ' supported by this browser.</b></p>';
                    } else {
                        zone.el.innerHTML = '<p><b>Problem listing ' +
                            root.name + '.</b></p>';
                    }
                });
            });

        });
    </script>
</body>

</html>