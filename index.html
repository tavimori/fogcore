<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Fork my world</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

    <script src='https://api.mapbox.com/mapbox-gl-js/v2.3.1/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.3.1/mapbox-gl.css' rel='stylesheet' />

    <script src="filedrop-min.js"></script>
    <script src="pako.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        /* 
        .map-overlay {
            font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            position: absolute;
            width: 25%;
            top: 0;
            left: 0;
            padding: 10px;
            background-color: transparent;
        }

        .map-overlay .map-overlay-inner {
            background-color: #fff;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 10px;
        } */

        .map-overlay {
            font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            position: absolute;
            width: 25%;
            top: 0;
            left: 0;
            padding: 10px;
        }

        .map-overlay .map-overlay-inner {
            background-color: #fff;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .map-overlay h2 {
            line-height: 24px;
            display: block;
            margin: 0 0 10px;
        }

        #zdir {
            /* border: 5px solid grey; */
            width: 100%;
            height: 100%;
            /* background-color: grey; */
        }
    </style>

</head>

<body>
    <div id='map'></div>

    <div class="map-overlay top">
        <div class="map-overlay-inner">
            <h2>Fork my world</h2>
        </div>
        <div class="map-overlay-inner">
            <!-- <h2>Fog my world</h2> -->
            <div id="zdir">
                <p>Please drag your "Sync" folder here, or click to choose every files inside it.</p>
            </div>
        </div>
    </div>



    <script>
        const FILENAME_MASK1 = "olhwjsktri";
        const FILENAME_MASK2 = "eizxdwknmo";
        var FILENAME_ENCODING = {};
        for (var i = 0; i < FILENAME_MASK1.length; i++) {
            FILENAME_ENCODING[FILENAME_MASK1.charAt(i)] = i
        }
        const MAP_WIDTH = 512
        const TILE_WIDTH = 128
        const TILE_HEADER_LEN = TILE_WIDTH ** 2;
        const TILE_HEADER_SIZE = TILE_HEADER_LEN * 2;
        const BLOCK_BITMAP_SIZE = 512;
        const BLOCK_EXTRA_DATA = 3
        const BLOCK_SIZE = BLOCK_BITMAP_SIZE + BLOCK_EXTRA_DATA
        const BITMAP_WIDTH = 64

        const ZOOM_LEVEL = 12

        class Block {
            constructor(x, y, data) {
                this.x = x;
                this.y = y;
                this.bitmap = data.slice(0, BLOCK_BITMAP_SIZE);
                this.extraData = data.slice(BLOCK_BITMAP_SIZE, BLOCK_SIZE);
            }

            is_visited(x, y) {
                var bit_offset = 7 - x % 8;
                var i = Math.floor(x / 8);
                var j = y;
                return this.bitmap[i + j * 8] & (1 << bit_offset);
            }

        }

        function tile_x_y_to_lng_lat(x, y) {
            lng = x / 512 * 360 - 180;
            lat = Math.atan(Math.sinh(Math.PI - 2 * Math.PI * y / 512)) * 180 / Math.PI;
            return [lng, lat];
        }

        function tile_lng_lat_to_x_y(lng, lat) {
            x = (lng + 180) / 360 * 512
            y = (Math.PI - Math.asinh(Math.tan(lat / 180 * Math.PI))) * 512 / (2 * Math.PI)
            return [x, y]
        }

        class Tile {
            constructor(filename, data) {

                // TODO: try catch
                this.id = filename.slice(4, -2).split("").map(idMasked => FILENAME_ENCODING[idMasked]).join("");
                this.x = this.id % MAP_WIDTH;
                this.y = Math.floor(this.id / MAP_WIDTH);
                // console.log()
                console.log(`Loading tile. id: ${this.id}, x: ${this.x}, y: ${this.y}`);

                // TODO: try catch
                this.data = pako.inflate(data);

                var header = new Uint16Array(this.data.slice(0, TILE_HEADER_SIZE).buffer)
                this.blocks = {}

                for (var i = 0; i < header.length; i++) {
                    var block_idx = header[i];
                    if (block_idx > 0) {
                        let block_x = i % TILE_WIDTH;
                        let block_y = Math.floor(i / TILE_WIDTH)
                        let start_offset = TILE_HEADER_SIZE + (block_idx - 1) * BLOCK_SIZE
                        let end_offset = start_offset + BLOCK_SIZE
                        var block_data = this.data.slice(start_offset, end_offset);
                        this.blocks[[block_x, block_y]] = new Block(block_x, block_y, block_data)
                    }
                }

                this.canvas = document.createElement("canvas");
                this.canvas.id = this.id.toString();

                this.zoom = ZOOM_LEVEL;
                this.renderCanvas();
            }

            renderCanvas() {
                var size = Math.floor(TILE_WIDTH * BITMAP_WIDTH / this.zoom)
                this.canvas.width = size;
                this.canvas.height = size;

                // Set actual size in memory (scaled to account for extra pixel density).
                var scale = window.devicePixelRatio; // Change to 1 on retina screens to see blurry canvas.
                this.canvas.width = Math.floor(size * scale);
                this.canvas.height = Math.floor(size * scale);

                var ctx = this.canvas.getContext("2d");

                ctx.scale(scale, scale);
                // ctx.translate(0.5,0.5)
                
                ctx.fillStyle = "#000000";
                ctx.strokeRect(0, 0, size, size);
                var blocks = Object.values(this.blocks);
                for (var i = 0; i < blocks.length; i++) {
                    var block = blocks[i];
                    for (var j = 0; j < BITMAP_WIDTH; j++) {
                        for (var k = 0; k < BITMAP_WIDTH; k++) {
                            var x = block.x * BITMAP_WIDTH + j;
                            var y = block.y * BITMAP_WIDTH + k;
                            x = Math.floor(x / this.zoom);
                            y = Math.floor(y / this.zoom);
                            if (block.is_visited(j, k)) {
                                ctx.fillRect(x, y, 1, 1);
                            }

                        }
                    }
                }
            }

            setZoom(zoom) {
                this.zoom = zoom;
                this.renderCanvas();
            }

            bounds() {
                let sw = tile_x_y_to_lng_lat(this.x, this.y + 1);
                let se = tile_x_y_to_lng_lat(this.x + 1, this.y + 1);
                let ne = tile_x_y_to_lng_lat(this.x + 1, this.y);
                let nw = tile_x_y_to_lng_lat(this.x, this.y);
                return [nw, ne, se, sw];
            }

        }
        class FogMap {
            constructor(map) {
                this.tiles = {};
                this.map = map;

                map.on('resize', () => {
                    console.log('A resize event occurred.');
                    // console.log(getZoom())
                    this.optimizeView();
                });

                map.on('remove', () => {
                    console.log('A remove event occurred.');
                    this.optimizeView();
                });

                map.on('dragend', () => {
                    console.log('A dragend event occurred.');
                    this.optimizeView();
                });

                map.on('zoomend', () => {
                    console.log('A zoomend event occurred.');
                    this.optimizeView();
                });


            }

            optimizeView() {
                console.log("optimizing view...");
                var bounds = this.map.getBounds();
                var sw = tile_lng_lat_to_x_y(bounds._sw.lng, bounds._sw.lat);
                var ne = tile_lng_lat_to_x_y(bounds._ne.lng, bounds._ne.lat);

                // FIXME: check if the region across lng=0
                var xMin = Math.floor(sw[0]);
                var xMax = Math.ceil(ne[0]) - 1;

                var yMin = Math.floor(ne[1]);
                var yMax = Math.ceil(sw[1]) - 1;

                var activeTiles = Object.values(this.tiles).filter(tile => (tile.x >= xMin) && (tile.x <= xMax) && (tile.y >= yMin) && (tile.y <= yMax));


                var mapRoom = this.map.getZoom();
                var fogRoom = Math.max(2**Math.floor(13 - mapRoom), 1);
                activeTiles.forEach(tile => tile.setZoom(fogRoom));
                // console.log(`zoom: ${zoom}`);
                // if (zoom < 8) {
                //     activeTiles.forEach(tile => tile.setZoom(20));
                // } else if (zoom < 10) {
                //     activeTiles.forEach(tile => tile.setZoom(12));
                // } else if (zoom < 12) {
                //     activeTiles.forEach(tile => tile.setZoom(4));
                // } else {
                //     console.log("set zoom");
                //     activeTiles.forEach(tile => tile.setZoom(1));
                // }

                console.log(`x: [${xMin}, ${xMax}], y: [${yMin}, ${yMax}]`);
                console.log(activeTiles);

            }

            addFile(filename, data) {
                try {
                    var tile = new Tile(filename, data)

                    this.tiles[[tile.x, tile.y]] = tile;

                    // load tile to map
                    map.addSource(tile.id.toString(), {
                        type: 'canvas',
                        canvas: tile.canvas,
                        coordinates: tile.bounds()
                    });

                    map.addLayer({
                        id: tile.id.toString(),
                        type: 'raster',
                        source: tile.id.toString()
                    });
                } catch (e) {
                    console.log(`${filename} is not a valid tile file.`)
                    // console.log(e)
                }


                // map.flyTo({
                //     center: tile.bounds()[0],
                //     essential: true // this animation is considered essential with respect to prefers-reduced-motion
                // });
            }
        }





        mapboxgl.accessToken = 'pk.eyJ1IjoidGF2aW1vcmkiLCJhIjoiY2ozeHh3NXdjMDAwYTJ3bnk2ZXhqbTkzbiJ9.BGLmrBqqXkZv50HKrwaZRQ';
        var map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v11',
            center: [114.20592531593752, 22.690129049232496],
            zoom: 10
        });


        // Add zoom and rotation controls to the map.

        map.addControl(new mapboxgl.FullscreenControl({ container: document.querySelector('body') }));
        map.addControl(new mapboxgl.NavigationControl({
            visualizePitch: true
        }));

        map.addControl(new mapboxgl.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: true
            },
            trackUserLocation: true,
            showUserHeading: true
        }));


        map.on('load', function () {
            var fogMap = new FogMap(map);

            // var zone = new FileDrop('zdir', { input: false });
            var zone = new FileDrop('zdir');
            zone.multiple(true);

            zone.event('send', function (files) {
                files.each(function (file) {
                    console.log(file.name + ' (' + file.size + ') bytes')
                    file.readData(
                        function (data) {
                            fogMap.addFile(file.name, data);
                        },
                        function (e) { console.log(`cannot read ${file.name}`) }
                    )
                })
            })

            zone.event('upload', function (e) {

                var error = function () { alert('Problem reading the file system.'); }

                var done = function (files) {
                    // files is standard FileDrop's FileList object.
                    files.each(function (file) {
                        // file is FileDrop.File with native objects accessible
                        // as file.nativeFile and file.nativeEntry.
                        // var node = document.createElement('p');
                        // node.innerText = file.name

                        if (file.nativeFile) {
                            // This is a file. We can use any FileDrop method here
                            // like sendTo() and readData() - see below.

                            file.readData(
                                function (data) {
                                    fogMap.addFile(file.name, data);
                                },
                                function (e) { console.log(`cannot read ${file.name}`) }
                            )

                        } else {
                            console.log(`${file.name} is a folder?`);
                            // file.listEntries(showfilenames, error)
                            // debugger;
                        }

                    });
                };

                zone.eventFiles(e).each(function (root) {
                    if (root.listEntries(done, error)) {
                        // Success.
                    } else if (!root.nativeEntry) {
                        zone.el.innerHTML = '<p><b>File System API is not' +
                            ' supported by this browser.</b></p>';
                    } else {
                        zone.el.innerHTML = '<p><b>Problem listing ' +
                            root.name + '.</b></p>';
                    }
                });
            });

        });

    </script>
</body>

</html>